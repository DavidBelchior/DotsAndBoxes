;; procura em largura
;; teste: (bfs '((((0 0 0) (0 0 1) (0 1 1) (0 0 1)) ((0 0 0) (0 1 0) (0 0 1) (0 1 1))) 0 nil) 'no-solucaop 'sucessores (operadores) 3)
;; resultado: ((((0 0 0) (0 1 1) (0 1 1) (0 0 1)) ((0 0 0) (0 1 0) (0 1 1) (0 1 1))) 2 NIL (((# # # #) (# # # #)) 1 NIL ((# #) 0 NIL)))
(defun bfs (initialNode fnSolucao fnSucessores operators obj &optional (abertos nil) (fechados nil))
  (cond ((and (null abertos) (null fechados)) (bfs initialNode fnSolucao fnSucessores operators obj (list initialnode) fechados) )
        ((null abertos) nil)
        (T 
          (let* ((n-fechados (append fechados (list (car abertos)))) (next-nodes (nos-unicos-bfs n-fechados (funcall fnSucessores (car abertos) operators 'bfs))) )
              (let* ((no-obj-val (no-obj next-nodes fnSolucao obj)) )
                (cond ((not (null no-obj-val)) 
                    (list abertos n-fechados no-obj-val))
                      (t (bfs initialNode fnSolucao fnSucessores operators obj (abertos-bfs (cdr abertos) next-nodes) n-fechados))
                )
              )
          )
        )
  )
)


;; procura em profundidade
;; teste: (dfs '((((0 0 1 0) (1 0 1 1) (0 0 1 1) (0 0 1 1) (0 0 1 1)) ((0 0 1 1) (0 0 1 1) (0 0 1 1) (1 0 1 1) (0 1 1 1))) 0 nil) 'no-solucaop 'sucessores (operadores) 30 10)
;; resultado: ((((1 1 1 1) (1 1 1 1) (0 0 1 1) (0 0 1 1) (0 0 1 1)) ((1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1))) 12 NIL (((# # # # #) (# # # # #)) 11 NIL ((# #) 10 NIL (# 9 NIL #))))
(defun dfs (initialNode fnSolucao fnSucessores operators depth obj &optional (abertos nil) (fechados nil))
  (cond ((and (null abertos) (null fechados)) (dfs initialNode fnSolucao fnSucessores operators depth obj (list initialnode) fechados))
        ((null abertos) nil)
        (T 
          (let* ((n-fechados (append fechados (list (car abertos)))) (next-nodes (nos-unicos-dfs abertos n-fechados (funcall fnSucessores (car abertos) operators 'dfs nil nil depth))) )
              (let ((no-obj-val (no-obj next-nodes fnSolucao obj)))
                (cond ((not (null no-obj-val)) 
                  (list abertos n-fechados no-obj-val))
                      (t (dfs initialNode fnSolucao fnSucessores operators depth obj (abertos-dfs (cdr abertos) next-nodes) (remove-sucessores-from-fechados n-fechados next-nodes)))
                )
              )
          )
        )
  )
)

;; procura na profundidade
;; teste: (astar '((((0 0 0) (0 0 1) (0 1 1) (0 0 1)) ((0 0 0) (0 1 0) (0 0 1) (0 1 1))) 0 1 nil) 'no-solucaop-astar 'sucessores (operadores) 'heuristica 3)
;; resultado: ((((0 0 0) (0 1 1) (0 1 1) (0 0 1)) ((0 0 0) (0 1 0) (0 1 1) (0 1 1))) 2 0 (((# # # #) (# # # #)) 1 1 ((# #) 0 1 NIL)))
;; teste: (astar '((((0 0 0) (0 0 1) (0 1 1) (0 0 1)) ((0 0 0) (0 1 0) (0 0 1) (0 1 1))) 0 1/3 nil) 'no-solucaop-astar 'sucessores (operadores) 'nossa-heuristica 3)
;; resultado: ((((0 0 0) (0 1 1) (0 1 1) (0 0 1)) ((0 0 0) (0 1 0) (0 1 1) (0 1 1))) 2 0 (((# # # #) (# # # #)) 1 1/9 ((# #) 0 1/3 NIL)))
(defun astar (initialNode fnSolucao fnSucessores operators fn-heuristica obj &optional (abertos nil) (fechados nil))
  (cond ((and (null abertos) (null fechados)) (astar initialNode fnSolucao fnSucessores operators fn-heuristica obj  (list initialnode) fechados))
        ((null abertos) nil)
        ((funcall fnSolucao (car abertos)) 
            (list abertos fechados (car abertos))) 
        (T 
          (let* ((n-fechados (append fechados (list (car abertos)))) (nos-sucessores (nos-unicos-astar abertos n-fechados (funcall fnSucessores (car abertos) operators 'astar obj fn-heuristica))))
            (let ((sucessores-fechados-menor-custo (sucessores-que-estao-em-fechados-com-menor-custo-astar n-fechados  nos-sucessores)))
             (astar initialNode fnSolucao fnSucessores operators fn-heuristica obj (colocar-sucessores-em-abertos (cdr abertos) nos-sucessores) (remove-sucessores-from-fechados n-fechados sucessores-fechados-menor-custo))
            )
          )
        )
  )  
)
   
